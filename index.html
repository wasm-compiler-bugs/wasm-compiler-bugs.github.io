---
title: An Empirical Analysis on WebAssembly Compiler Bugs
layout: default
--- 
<style>
    table {
        width: 100%;
    }
    .narrow{
        width: 10%;
    }
    .wide{
        width: 45%;
    }
</style> 
 <p>This repo contains the figures and data presented in the ISSTA 2021 submission &quot;An Empirical Analysis of WebAssembly Compiler Bugs&quot;.</p>


 <h2 id="dataset"><a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Dataset">Dataset</a></h2>
 <p>This folder contains the samples collected from the qualitative study,&nbsp;<a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Dataset/qualitative_dataset.csv">qualitative_dataset.csv</a>, and the quantitative dataset,&nbsp;<a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Dataset/quantitative_dataset.csv">quantitative_dataset.csv</a>.</p>
 
 <h3>Quantitative Study Bug Collection</h3>
 <p> The bug dataset is constructed by scanning the repositories of six compilers, AssemblyScript, Asterius, Binaryen, Emscripten, TinyGo, and Wasm-Bindgen (obtained from <a href="https://github.com/mbasso/awesome-wasm">this list</a>), to identify issues that contained bug reports. We do this using two approaches.</p>
 <p>In the first approach, we use the GitHub Search API to collect all the closed issues that had a label indicating the issue was a bug, including &quot;bug&quot;, &quot;good first bug&quot;, &quot;breaking change&quot;, etc... This produced a total of 243 issues. </p>
 <p>In the second approach, we use the GitHub REST API to collect all the issues from the six compilers, arriving at a total of 96,186 issuess.  We limit these bugs to closed issues in order to reliably obtain information on the bug fix and root cause, which reduces the number to 88,037 issues. We restrict the bugs to those after the year 2015 as this is when the initial versions of WebAssembly were introduced, bringing the number to 64,673. Next, we search for keywords in the title and body of the issue to include, such as &quot;bug&quot;, &quot;error&quot;, &quot;defect&quot;, and &quot;fault&quot;, and to excude, such as &quot;feature&quot; and &quot;install&quot;. This filter reduces the number of issues to 19,335. We apply more keywords to search for issues that are particularly relevant to WebAsembly using &quot;wasm&quot;, &quot;wat&quot;, and &quot;WebAssembly&quot;. This brings the number down to 1,752 issues. </p>
 <p>The issues from both apporaches are combined (243 issues using the bug labels, 1,752 using keywords). Finally, the issues are manually inspected to verify that they are closed issues related to WebAssembly with a reported bug fix. This manual inspection brings the number of issues to the final number of 1,400.</p>

 <h3>Qualitative Study Bug Collection</h3>
<p>We obtain the bug for the qualitiative study by filtering the dataset used in the quantitative study (1,400 samples) to those that belong to Emscripten (430 samples) and contain a bug-inducing input to obtain 142 samples. </p>

<h2 id="code"><a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Code">Code</a></h2>
<p>This folder contains the source code of the tool used to crawl GitHub for the bug samples process and perform the data processing/counting of the issues collected. The folder also includes the script used to build the visualizations used in the paper. </p>

 <h2 id="findings">Findings</h2>
 <table class="table" >
 <thead>
 <tr>
 <th class="narrow"></th>
 <th class="wide">Findings</th>
 <th class="wide">Implications</th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td colspan="3" align="center"><b>From Qualitative Study (Section 3)</b></td>
 </tr>
 <tr>
 <td>1</td>
 <td>Data type incompatibilities bugs account for 32.8% of the 61 bugs.</td>
 <td>Interfaces passing values among WebAssembly, JavaScript, and C/C++ contexts should be tested exhaustively as they support compiler-provided runtime libraries (e.g., Filesystem, Exception Handling).</td>
 </tr>
 <tr>
 <td>2</td>
 <td>Porting synchronous C/C++ paradigm to event-loop paradigm is uniquely challenging.</td>
 <td>Automated tools supporting this conversion (e.g.,&nbsp;<a href="https://emscripten.org/docs/porting/asyncify.html">Asyncify</a>) require thorough testing. Libraries relying on them may suffer from incorrect event ordering as described in Section 3.2 (e.g.,&nbsp;<a href="https://github.com/emscripten-core/emscripten/issues/9823">Emscripten-#9823</a>).</td>
 </tr>
 <tr>
 <td>3</td>
 <td>Handling the differences in memory management models is challenging.
</td>
 <td>Libraries utilizing linear memory, such as the Filesystem API, should be tested rigorously under diverse memory conditions (e.g., workloads requiring memory growth and shrinkage).</td>
 </tr>
 <tr>
 <td>4</td>
 <td>Bugs or benign changes that occur within external infrastructures used in WebAssembly compilers can lead to bugs in the compiler.</td>
 <td>Compiler developers should stay on top of developments that occur in the existing infrastructure used within the compiler. Although they are more mature, new bugs can occur when used to support WebAssembly.</td>
 </tr>
 <tr>
 <td>5</td>
 <td>Despite WebAssembly being platform-independent, platform differences in browsers and operating systems can cause bugs in the emitted modules.</td>
 <td>By default, when testing emitted WebAssembly modules for tests in the test suite, they should be run against multiple browsers and runtimes, rather than just the V8 browser or Node.js runtime, which are the current default settings.</td>
 </tr>
 <tr>
 <td>6</td>
 <td>WebAssembly limitations, such as the lack of support for the C keyword sigsetjmp and function type bitcasting, can lead to bugs being reported in the compiler.</td>
 <td>WebAssembly compiler developers should be sure to document these limitations to avoid wasting effort to look into issues that run against these limitations.</td>
 </tr>
 <tr>
 <td colspan="3" align="center" ><b>From Quantitative Study (Section 4)</b></td>
 </tr>
 <tr>
 <td>7</td>
 <td>Bugs that are slow to fix are either complex issues, caused by external projects, or are difficult to reproduce due to lack of information (e.g., compilation options) in the bug report.</td>
 <td>The compiler developers can improve bug reporting techniques (e.g., automatically including the relevant compilation options into a log file for issue reports) to ease the bug reproduction process.</td>
 </tr>
 <tr>
 <td>8</td>
 <td>Bugs that manifest during runtime made up a significant portion (37.8%) of the bugs inspected, including bugs that cause incorrect functionality (10.1%), crashes (9.60%), and data corruption (6.94%).</td>
 <td>Runtime bugs are more difficult to detect and fix than bugs that occur during compile time. In order to mitigate these bugs, compiler developers should be sure to test the emitted modules in the test suites more exhaustively.</td>
 </tr>
 <tr>
 <td>9</td>
 <td>Over 50% of bugs for five compilers affect only 1 file.</td>
 <td>Bugs are localized within a few core files, that are covered by the existing test-suites. However, the test-suites failed to expose errors due to the insufficient input and scenario coverage. Developers could improve the test-suites’ quality. The existing test suites achieve sufficient code coverage while failed to cover diverse inputs and scenarios. Developers could spend more effort on covering more input space and diverse scenarios. 
 </tr>
 <tr>
 <td>10</td>
 <td>The majority of bug-inducing inputs (76.1%) have 10 or fewer lines of code. We observe cases where initial bug-inducing inputs were large and further reduced by developers.</td>
 <td>In many cases, bug-inducing inputs do not need to be very large. This can help guide techniques for test-case generation and motivate bug-inducing input reduction techniques (e.g., delta-debugging).</td>
 </tr>
 <tr>
 <td>11</td>
 <td>Over 88% of all bug fixes are 100 lines or fewer, and 51% of all bugs fixes are 10 lines or fewer. Over 78% of bugs are fixed by changing 10 functions or less.</td>
 <td>Bug fixes are usually not very large/complex to resolve the issue (i.e., fixes did not require significant refactoring effort).</td>
 </tr>
 </tbody>
 </table>
 Our findings can be used to help guide testing improvements in WebAssembly compilers. For example, Implication 9 states that the current Emscripten test suite is comprehensive enough to cover relevant APIs but not deep enough to find complex bugs. In <a href="https://github.com/emscripten-core/emscripten/issues/9562">Emscripten Issue #9562</a>, the report describes a bug where using the <code>-s MAIN_MODULE=1</code> compiler flag with a code snippet utilizing the Filesystem API causes a type error that passes an illegal value between WebAssembly and JavaScript. This bug should be covered by the test cases for dynamic linking <a href="https://github.com/emscripten-core/emscripten/blob/635c4608fbcc34b025267e0b626f3f245296f4e6/tests/test_browser.py#L3425">test_dynamic_link,  test_dylink_dso_needed, ...</a> or the test cases for the filesystem <a href="https://github.com/emscripten-core/emscripten/blob/635c4608fbcc34b025267e0b626f3f245296f4e6/tests/test_browser.py#L4501">test_asmfs_hello_file, test_asmfs_read_file_twice, etc...</a>. However, the bug-inducing input manages to avoid hitting these test cases as the two APIs were not tested in combination with each other.</td> 


 <h3 id="figures"><a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Figures">Figures</a></h3>

 <p>All of the figures used in the paper can be found in the <a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Figures">Figures</a>
 directory. The figures are provided as high-resolution .png and .pdf files.</p>

 <h3 id="tables"><a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Tables">Tables</a></h3>
 <p>All of the tables used in the paper can be found in the <a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/Tables">Tables</a> directory with the table numbers matching those found in the paper. There are also tables that were ommitted from the paper for space. The tables are provided as high-resolution .png files.</p>
 <h3 id="-compiler-signatures-https-github-com-wasm-compiler-bugs-wasm-compiler-bugs-github-io-tree-master-compilersignatures-"><a href="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/tree/master/CompilerSignatures">Compiler Signatures</a></h3>
 <p>This folder contains some of the signatures collected for the compilers in our study on WebAssembly samples in the wild. The compiler signatures are presented for Emscripten, Binaryen, and Wasm-Bindgen, as well as for samples whose compiler could not be determined.</p>

 <h2 id="qualitative-study">Qualitative Study</h2>
 <p>We perform a qualitative analysis on 142 bugs. We collect the information in the qualitative study through the following steps: </p>
 <ol>
 <li>Beginning with the Columns <em>ID</em> and <em>URL</em>, we first visit the issue page through the link in <em>URL</em>.</li>
 <li>We identify bug-inducing code snippet in the page by reading the initial post and, if need, a few of the following posts. We record the source code language of the bug-inducing input in the <em>Language</em> column and the link to the post containing the bug-inducing input in the <em>Bug Inducing Input Location</em> column.</li>
 <li>We identify the intended functionality that the code snippet is trying to trigger and record in the column <em>Purpose</em>. We list the indicative API/keyword that helps us identify the purpose of the code snippet in the <em>Tested API</em> column.</li>
 <li>We read through all the posts in the issue conversation to find what the compiler developers and/or reporting user found the root cause to be. We also read any linked issues if the root cause cannot be determined from the issue conversation. We summarize the root cause and record it in the <em>Root Cause</em> column. </li>
 <li>We read through all the posts to find out how the bug was fixed or resolved. We summarize the bug fix and record it in the <em>Bug Fix</em> column.</li>
 <li>After performing Steps 1-5 on all the samples, we look at the root cause summaries in the <em>Root Cause</em> column to group similar ones together. We distinguish the causes by where they occur in the compiler infrastructure (e.g. frontend, linker, lirbaries, etc.. ) or by differences in the languages, platforms, or infrastructures involved (e.g C-to-WebAssembly, WebAssembly-to-JS,...). We record the final categories created in the <em>Root Cause Category</em> column.</li>
 </ol>
 <h3 id="sample-emscripten-bug-9562-https-github-com-emscripten-core-emscripten-issues-9562-">Sample <a href="https://github.com/emscripten-core/emscripten/issues/9562">Emscripten Bug #9562</a></h3>
 <pre><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
 
 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     FILE* file_ = <span class="hljs-built_in">std</span>::fopen(<span class="hljs-string">"input.txt"</span>,<span class="hljs-string">"rb"</span>);
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"file pointer %p\n"</span>,(<span class="hljs-keyword">void</span>*)file_);
     <span class="hljs-keyword">if</span> (file_) {
         <span class="hljs-built_in">std</span>::fseek(file_, <span class="hljs-number">0l</span>, SEEK_END);
         <span class="hljs-built_in">std</span>::fclose(file_);
     }
     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }
 </code></pre><p>We find that a bug occurs when using a file
 pointer and compiling the module
 with option -s MAIN_MODULE=1. Emscripten provides a filesystem
 library, FS, implemented in JavaScript that emulates filesystem functionality, and it is accessed
 in WebAssembly through imports. Since JavaScript does not natively support 64-bit integers, this
 is usually handled by adding a legalization step that converts the
 value into a type JavaScript can support. Within the execution path
 to fseek(), an indirect call attempts to pass a WebAssembly i64
 value to exported WebAssembly function of a side module. The
 issue is that this other module’s export function has been wrapped
 in JavaScript code to support value legalization.
 The issue is fixed by exporting legalized and non-legalized versions of WebAssembly functions so that function calls made through
 the indirect calls used here can pass i64 values to the appropriate
 function when legalization is not required.</p>
 <h2 id="quantitative-study">Quantitative Study</h2>
 <p><img src="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/raw/master/Tables/Table4.PNG" alt="Table 4: Bug Dataset"></p>
 <p>In the second study, we perform a quantitative study on 1,400 bugs among six WebAssembly compilers, namely AssemblyScript, Asterius, Binaryen, Emscripten, TinyGo, and Wasm-Bindgen.</p>
 <p>This study focuses on four dimensions: (a) We study the lifecycle of the bugs and find that the average duration of the bugs is 118 days, with 26.4% of all bugs being fixed within 1 day.(b) We categorize these bugs based on their impacts and observe many runtime errors (37.8%), including crash (9.6%), instantiation failure (1.2%), and performance drop (0.8%). (c) We study the locations of the bugs and find that most bugs are concentrated to a few files in the projects. 47 bugs are found in the component sof existing compiler infrastructures. (d) We compute the lines of code (LOC) of the bug-inducing inputs and bug fixes. We find that majority of bug-inducing inputs (76.1%) have 10 LOC or less. 51.4% of the bugs have bug fixes with less than 10 LOC, and 78% are fixedby changing at most 10 functions.</p>
 <h2 id="real-world-webassembly-adoption-study">Real-World WebAssembly Adoption Study</h2>
 <p><img src="https://github.com/wasm-compiler-bugs/wasm-compiler-bugs.github.io/raw/master/Figures/compiler_dist.png" alt="Figure 15: Distribution of WebAssembly Compilers"></p>
 <p>Our analysis shows that Emscripten is the most widely-used compiler for creating real-world WebAssembly samples. Besides, Binaryen and Wasm-Bindgen have also been observed in the wild. Fig. 15 shows the distribution of identified compilers, where the left Fig. 15(a) counts all individual samples and the right Fig. 15(b) only counts unique samples. There are duplicated samples because multiple websites used the same WebAssembly binary. As shown in Fig. 15(a), Emscripten accounts for 68% (2,434 samples) of all samples, Binaryen takes 31% (1,133 samples), and Wasm-Bindgen accounts for 1% (38 samples). When considering distinct samples, Emscripten accounts for 95% (752 samples) of the unique samples, followed by Wasm-bindgen (4%, 32 samples), and Binaryen (1%, 7 samples).</p>
